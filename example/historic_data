#!/usr/bin/env ruby
#
# This script downloads historic data for specific symbols from IB

require 'rubygems'
require 'bundler/setup'
require 'yaml'
$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__) + '/../lib')
require 'ib/ord'
# Connect to IB TWS.
# It is safe to connect to a production-machine. 
#                            change host to ip of the computer, where a tws (or gateway)
#                            with marketdata-subscriptions is running
logger =  Logger.new '/dev/stdout'
logger.level= Logger::WARN
logger.formatter = proc do |severity, datetime, progname, msg| 
     "#{datetime.strftime("(%X)")}#{"%5s" % severity}->#{progname}:..:#{msg}\n" 
end
ActiveOrient::Base.logger =  logger
ActiveOrient::OrientDB.logger =  logger
require 'ib-ruby'
gw = IB::Gateway.new  connect: true ,  client_id: 1289 ,  host: 'beta:7496', # or 'localhost'
		      logger: logger


if ( ib= IB::Gateway.tws).present? 

  # Definition of what we want data for.  
  EXPIRY =  '201612'
  the_contracts =[ IB::Stock.new( symbol:'T' ),
		  IB::Future.new( symbol:'ES', exchange: 'GLOBEX' , expiry:EXPIRY, :multiplier => 50),
		  IB::Forex.new( :symbol => 'AUD', :currency  =>'USD')
		].map do |x| 
		  x.verify do |contract| 
		    IB::Contract.upsert where: {con_id: contract.con_id}, set: contract.attributes 
#		    contract.update
		    puts "Added verified Contract #{contract.to_human} to IB:Contracts"
		  end
		  x
		end
  print_ohlc = ->(obj) do
    print obj.time.strftime( "%d.%m.%Y %H:%M")  + " >>  "+
      "%8.3f \t" % obj.open +
      "%8.3f \t" % obj.high + 
      "%8.3f \t" % obj.low  +
      "%8.3f \t||" % obj.close +
      "%8d \n" % obj.volume 
  end
  print_ohlc_title = -> do 
    print " ##  "+ "%8s  \t" % "open" + 
      "%8s  \t" % "high" +
      "%8s  \t" % "low" +
      "%8s  \t||" % "close" +
      "%8s  \n" % "volume" 
    puts "-"*100
  end

  responded = []


  # Subscribe to Alerts and HistoricalData incoming events.  The code passed in the block
  # will be executed when a message of that type is received, with the received
  # message as its argument. In this case, we just print out the data.
  #
  # Note that we have to look the ticker id of each incoming message
  # up in local memory to figure out what it's for.
  ib.subscribe( IB::Messages::Incoming::HistoricalData ) do |msg|
    contract = IB::Contract.where( con_id: msg.request_id ).first
    case msg
    when IB::Messages::Incoming::HistoricalData
      puts "-"*100
      print "%8s" % contract.local_symbol + ": #{msg.count} items"
      print_ohlc_title[]
      msg.results.each do |entry|  
	entry.time = DateTime.parse(entry.time)
	print_ohlc[entry] 
	IB::Bar.upsert where: { time: entry.time, contract: contract }, set: entry.attributes
      end
      responded[msg.request_id] =  1
    else 
      puts msg.to_human
      responded[msg.error_id.abs] =  1
    end
  end

  # Now we actually request historical data for the symbols we're interested in. TWS will
  # respond with a HistoricalDa#ta message, which will be processed by the code above.
  the_contracts.each do | contract |

    IB::Gateway.current.send_message IB::Messages::Outgoing::RequestHistoricalData.new(
      :request_id => contract.con_id,
      :contract => contract,
      :end_date_time => Time.now.to_ib,
      :duration => '3 D', #    ?
      :bar_size => '1 hour', #  IB::BAR_SIZES.key(:hour)?
      :what_to_show => :trades,
      :use_rth => 1,
      :format_date => 1)
  end

  # IB does not send any indication when all historic data is done being delivered.
  # So we need to interrupt manually when our request is answered.
  #puts "\n******** Press <Enter> to exit... *********\n\n"
 STDIN.gets
  # or
 # sleep(0.2) while responded.length <= gw.advisor.contracts.length
  gw.disconnect

else
  puts "No TWS"
end
